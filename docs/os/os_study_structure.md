# OS 学习框架

> 这两天，公众号、朋友圈都被跨年祝福、年终总结、新年 flag 刷疯了。我这边就不跟风了，趁着这跨年的东风，闲聊一下操作系统的学习路径、方法。
> 

## 一 概况

在软件的开发过程中，随着业务系统的日趋复杂，功能日渐增强，软件系统的规模也大幅膨胀。更何况是像操作系统这样的大型软件系统。

截止目前，Linux kernel 最近版本 5.4 ，代码已达到 2700 w 行。
图：

![Linux-kernel_codeline_scales](http://cdn.talkaboutos.top/Linux-kernel_codeline_scales.png)

图片来源：Wikipedia

另外，据悉现在的 Windows 10 的代码量达到了 6500 W 量级。

面对如此庞大的系统，如果要从头到尾一行一行代码地看懂，弄明白，不仅仅是难度大的问题，更是十分不切实际的空想。显然，我们必须找到行之有效的方法才能进一步学习。


## 二 学习路径

结合我们的学习目标及操作系统的复杂性，我们首先要做的便是从整体出发，抓住主要矛盾，忽略次要问题，先建立对操作系统的整体的印象。

操作系统虽说是理论上的东西，但具体系统的实现确是工程的产物。代码上不仅仅只是理论的翻译，更体现了工程实现上的思想方法。纵观 Linux kernel ，从系统的架构，到具体的代码实现上，无处不透露着工程性。这种风格的代码，实在不适合作为操作系统初学者的入门学习。

另外，Linux 系统是通用操作系统，在各种体系架构上比如常见的 X86、ARM 架构，另外在 MIPS、PowerPC、SPARC 等众多小众硬件架构上都跑得起来。如此广泛的架构支持，必然是以付出某种代价为前提。这个代价便是系统的复杂性，以及为兼容众多的硬件架构而单独开发的专用代码，比如 `/arch/` 目录下的架构代码。这种通用性也意味着内核代码中存在为数不少的重复性代码。

除却这些，考虑到内核代码是操作系统理论的工程实现，必然考虑到了工程中的各种细节问题，比如各种异常处理，特定条件下的可行性问题等等。如果一开始就被这些细节迷惑住，势必影响到后续进一步的学习。

因此，我们不能只见树木，不见森林。要从整体的角度，站在宏观层面上，学习这些系统设计背后的思想和考量。只有这样，才可能更为快速、有效地进入操作系统的学习中。


## 三 核心模块

操作系统包括内存、进程及进程调度、IO 和文件系统以及驱动这几大核心模块。


#### 内存：

内存，用于存储 CPU 执行程序代码所需的数据。内存管理算法很多，从简单的连续内存分配，到分段和分页机制，各种方法都有各自的优点和缺点。为特定的系统选择合适的内存管理方法取决于很多因素，尤其是系统的硬件设计。

内存这块，还有一个很重要的概念是虚拟内存。通过虚拟内存技术，应用程序可以使用比实际物理内存大得多的内存空间 。另外，虚拟内存技术将内存抽象成一个巨大的、统一的存储空间，进而将用户看到的逻辑内存与物理内存分开。这样便极大地便利了对内存的访问控制以及在进程间的文件和地址空间共享。不过，虚拟内存的实现并不很容易，如果使用不当可能会大大地降低性能。


#### 进程和进程调度：

进程，是对运行中的程序及其所拥有的资源（如 CPU、内存、文件、IO 设备等）的抽象。进程是操作系统理论中很重要一个概念。进程这一块，主要包括进程操作（进程创建、进程终止），进程调度（各种调度算法），以及未来提高资源利用率、避免死锁而进行的进程间的通信和同步。


#### IO 与文件系统：

计算机本就是为解决计算问题而设计的，所以输入输出（IO）是计算机系统的基本功能模块之一。计算机对输入的数据进行计算后，输出结果到输出设备或文件。
文件系统提供了存储和访问计算机操作系统和所有用户的程序和数据的机制。文件系统永久地驻留在外存上，外存可以永久地存储大量数据。文件系统设计有两个不同的问题，其一是创建数据结构和算法将逻辑文件系统映射到物理外存设备上；其二是如何定义文件系统对用户的接口。

#### 驱动：

操作系统往往支持众多的外设，而这些硬件设备又需要执行特殊指令和处理中断等特权，所以用户应用程序一般不能直接和硬件通信。设备驱动程序则承担了硬件交互的工作，同时也为应用程序和内核中其他的部分访问这些设备提供接口。

![Lines_of_linuxker](http://cdn.talkaboutos.top/Lines_of_linuxker.png)

Linux kernel 代码组成

图片来源：[https://github.com/udoprog/kernelstats](https://github.com/udoprog/kernelstats)


通过上图可以看到，Linux 内核中设备驱动程序代码占了总代码量的一半左右。可见驱动程序规模之大。不过，这些驱动程序的代码树大都相似，区别只在具体设备的控制方式上而已。

**未来已来，将至已至。新的一年，让我们只争朝夕，不负韶华，一起冲冲冲！**



---
<br>

![qr_code](http://cdn.talkaboutos.top/qr_code.png)

 StrokMitream
2020/01/03

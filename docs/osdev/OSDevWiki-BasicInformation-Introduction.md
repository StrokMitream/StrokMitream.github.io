# OSDev Wiki——操作系统开发入门基础（一）


本文翻译自 [OSDev.org](https://wiki.osdev.org/Main_Page)

**由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。**

---


以下是译文。
---
> **目录**
> * [1 Welcome](#1)
> * [2 操作系统是什么？](#2)
> * [3 内核（kernel）是什么？](#3)
> * [4 `shell` 是什么？](#4)
> * [5 GUI 是什么？](#5)
>   * [5.1 桌面环境，窗口管理程序，组件库](#5.1)
>   * [5.2 论坛 GUI 相关的帖子](#5.2)
> * [6 为什么要开发一个操作系统？](#6)
>   * [6.1 获得对机器完全地控制](#6.1)
>   * [6.2 研究](#6.2)
>   * [6.3 为了替代现在使用的系统](#6.3)
>   * [6.4 因为开发操作系统是一个有趣的过程](#6.4)
> * [7 相关条目](#7)
>   * [7.1 文章](#7.1)
---

## 1 Welcome<span id="1"> </span>
欢迎加入到操作系统开发的行列，勇敢的开拓者们！

并不是所有人都会在这个领域取得“成功”，不少人甚至连操作系统开发的入门课都未通过。不过，这或许并不会妨碍你更进一步，开创出下一个 `Linux` 或 `Windows` ？亦或是稍低一点的目标，`MenuetOS` 或 `CP/M` ？

无论你的目标为何，操作系统开发都是程序开发的巅峰，这是毋庸置疑的。不过，你并不孤独。我们整个网站，包括[网站论坛](http://forum.osdev.org/)和该 Wiki，都是致力于操作系统开发的。

在这儿，不仅仅是交流编程技巧，更是交流感情和友谊的地方。相信在学习过程中，你一定能与网络另一端的建立良好的友谊。

在操作系统开发中，想要取得“成功”，你该怎么做呢？

首先，你应该阅读一下 [ Getting Started](https://wiki.osdev.org/Getting_Started) 这篇文字。如果你打算使用 C/C++ 作为你的开发语言，那么你需要构建 [ GCC Cross-Compiler](https://wiki.osdev.org/GCC_Cross-Compiler)。而如果你偏爱其他语言，那么你同样得准备类似的工具（例如，编译器）。

这一切都得你自己付出精力。但是，用你喜欢的语言可能给你的工作带来不少激励和兴奋。

祝你好运！

## 2 操作系统是什么？<span id="2"> </span>
操作系统是一套软件，控制对计算机系统的操作和资源。其主要功能包括：
* 管理内存及其他系统资源。
* 实施安全管控和访问控制策略。
* 调度和多进程与多线程。
* 启动及关闭用户程序，同时为这些用户程序提供基本的系统服务。
* 提供基本的用户接口和应用程序编程接口。

并不是所有的操作系统都提供所有这些功能。像 `MS-DOS` 这样的单用户系统并没有进程调度功能，而像 `eCOS` 这样的嵌入式系统则可能没有用户界面。

然而，操作系统 **不是**：
* 计算机硬件。
* 一个具体的应用程序如，字处理程序，Web 浏览器或游戏。
* 一套工具（如在许多类 `Unix` 系统中广泛使用的 `GUN tools`）。
* 一套开发环境（尽管有些系统，比如 `UCSD Pascal` 、`Smalltalk-80`自带有解释器和 IDE ）。
* 一套图形用户界面（不少现代操作系统都集成有 GUI 界面）。

尽管大多数的操作系统在分发的时候都自带有这样或是那样的工具，可这些工具本身并非是 OS 的必需组件。

一些操作系统如 `Linux`，通常被封装成不同的封包形式发布， 不同的封包往往封装有不同的工具套件和应用程序，在软件组织方式也存在差异，这些不同的封装的系统，一般称为发行版（*distributions*）。

尽管如此，这些不同的发行版只是基于基本 OS 封装有各自的工具套件而已，不应该被认为是不同类型的操作系统。

## 3 内核（kernel）是什么？<span id="3"> </span>

操作系统内核是操作系统中用户永远无法看见的部分。

内核的基本功能是保证其他程序能正常执行。

它负责处理硬件产生的事件（称为*中断*）、软件产生的事件（*系统调用*）以及管理资源的访问。

**系统中断硬件事件处理程序（*中断处理程序*）**，举例来说，就是记录你按下的按键，并将它转换成相应的字符存储在缓冲区中，以便某些程序索取这些数据。

而**系统调用**则是由用户级程序发起的，比如说打开文件，启动其他程序的过程等等，都是在调用*系统调用*。

每一个系统调用处理程序都会检查用户程序传递的参数是否合法，然后才进入系统内部，响应用户程序请求。

大多数用户程序（除了汇编程序）并不直接调用*系统调用*，而是使用标准库，这些库通常处理参数格式化和生成系统调用的任务（例如，C 函数 `fopen()` 最终是调用内核函数打开文件）。

另外，内核通常定义有一些抽象概念，比如文件，进程，套接字，目录等等。这些抽象概念用于记录了上个会话的系统内部状态，所以程序可以更加有效地处理新的操作会话。

## 4 `shell` 是什么？<span id="4"> </span>

`shell`是一个提供人机交互接口的特殊程序，通常集成到系统发行版中。

从用户角度来看，`shell` 往往因系统而异，在不同的系统上体现形式也不一样（如：cmd 形式的命令行，文件资源管理器等等）；

不过，其主要功能不外乎以下几点：
* 允许用户选择一个程序启动，同时可以选择性地传递某些具体会话参数。
* 允许对本地存储器进行一些琐碎的操作，像列出目录下的内容，跨系统文件剪切和拷贝。

为了完成这些操作，`shell` 需要调用若干的系统调用。

比如，“打开文件 `x` ；打开文件 `y`，如果不存在就新建一个；读取 `X` 的内容，写入 `Y` 中，然后关闭 `X`、`Y`这两个文件，给标准输出返回“操作完成”信号 ”。

此外，`shell` 还可以被应用程序用来调用其他程序，靠其他程序来完成自身无法完成的工作（例如，生成“\*.mp3”，取得某个程序的确切路径等等）。
现代 `shell` 还具有不少其他额外的功能特性，

举例如下：
* 自动补全：按 `TAB` 键（或其他补全功能键），用户输入的字符会自动补全为有效的 shell 命令，文件名，目录或其他内容。连续多次敲击自动补全键，可列出当前所有可能的命令选项。
* 字符插入：用户可以通过方向键在 `shell` 中移动光标位置。当光标位于一行命令中间时，此时便可将新的命令“插入”其中。
* shell 命令历史：通过 方向键 `↑` 键和 `↓` 键，用户可以翻看之前输入的命令行。
* 屏幕滚动：当输出内容超过控制台的行高时， `shell` 可以把输出存入缓冲区中，以便用户上下翻页。
* 脚本支持：一些 `shell` 具有订制的脚本语言，如 `bash`，`DOS` 的批处理。
* ......

## 5 GUI 是什么？<span id="5"> </span>
Graphical User Interface (GUI,图形用户界面)，是操作系统最具可视化的部分。其扮演的角色已然超出了一个简单图形绘制库的范围。

GUI 的主要功能包括：
* 捕获用户输入事件（键盘，鼠标等等）并将这些事件派遣给恰当的处理对象。
* 更新内部关于哪些内容需要显示，显示在哪个位置，屏幕哪个部分需要刷新显示的信息。
* 更新屏幕的当前显示内容，刷新绘制必要的部分。
* 以自然、直观的方式，响应用户。

### 5.1 桌面环境，窗口管理程序，组件库<span id="5.1"> </span>

当你在 `KDE` 或 `Windows` 打开新的会话，那么这便是一个桌面环境。

系统中负责组织众多运行程序窗口，窗口缩放/关闭，窗口边界，滚动条等等的，是窗口管理器。

最后，还需要有子系统负责绘制这些窗口元素，渲染屏幕显示的文档等等，这便是我们常说的 组件库。不过，一些声明式语言（例如，Mozilla 的 XUL ,Qt 的 QML）也可实现类似的功能。

### 5.2 论坛 GUI 相关的帖子<span id="5.2"> </span>
* [Will you implement a GUI?](http://forum.osdev.org/viewtopic.php?t=8783)

* [GUI design](http://forum.osdev.org/viewtopic.php?t=9432)

* [Handling input events in GUI](http://forum.osdev.org/viewtopic.php?t=9448)

## 6 为什么要开发一个操作系统？<span id="6"> </span>
人们选择开发一个 OS 的原因各异，但是，对于绝大多数开发者来说，可能有这几条是共同的：


### 6.1 获得对机器完全地控制

当在开发应用程序或其他用户级程序时，开发者需要考虑其他人写的代码，如操作系统，各种库，其他程序等等。写操作系统能让人感到对机器的强有力控制。

### 6.2 研究
有相当一部分操作系统项目是家庭作业和研究项目。想要在一年的期限内完成一个操作系统的作业，实在不是一个很好的想法，毕竟时间太紧张。而研究项目往往是为了改进、提高现有的操作系统。新手们经常犯的错误，往往是严重低估了从头写一个系统所需的时间。

### 6.3 为了替代现在使用的系统
或许是因为现有的系统无法满足开发者的某些特定需求，或许是因为这些系统令人生厌（Linux 太过庞大，Windows 不够稳定）。这可能是为了盈利目的，尽管这个周期将会十分漫长。

### 6.4 因为开发操作系统是一个有趣的过程
低级（语言）编程开发是一个充满趣味和刺激的任务，所有的一切都需要你自己处理。这似乎很困难，然而，正是因此而更加有趣。你可以知道所有这些是如何运作的，所有你程序内部的工作。

很可惜的是，不少操作系统项目都是不合理的条件下启动的。参见 [Beginner Mistakes](https://wiki.osdev.org/Beginner_Mistakes) 列表。


## 相关条目<span id="7"> </span>
**文章<span id="7.1"> </span>**
* [Required Knowledge](https://wiki.osdev.org/Required_Knowledge)
* [Beginner Mistakes](https://wiki.osdev.org/Beginner_Mistakes)

---

原文：[https://wiki.osdev.org/Introduction]

